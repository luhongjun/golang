# 汇编指令

## 简单传送指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| MOV | 传送指令 | MOV DEST,SRC | DEST<=SRC |
| XCHG | 交换指令 | XCHG OPER1,OPER2 | 把操作数oper1的内容与操作数oper2的内容交换 | oper1和oper2可以是通用寄存器或存储单元，但不能同时是操作单元，也不能是立即数 |

## 简单加减指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| ADD | 加法指令 | ADD DEST,SRC | DEST<=DEST SRC | 两数相加 |
| SUB | 减法指令 | SUB DEST,SRC | DEST<=DEST-SRC | 两数相减 |
| INC | 加1指令 | INC DEST | DEST<=DEST 1 | - | 
| DEC | 减1指令 | DEC DEST | DEST<=DEST-1 | - |
| NEG | 取补指令 | NEG OPRD | OPRD=0-OPRD | 对操作数取补（相反数） |

## 标志寄存器及其使用

### 状态标志

| 标志 | 中文名 | 解释 |
| --- | --- | --- |
| CF（carry flag） | 进位标志 | 主要反映算术运算是否产生进位或借位，若产生，则CF=1，否则CF=0 |
| ZF | 零标志 | 反映运算结果是否为0 |
| SF（sign flag） | 符号标志 | 根据运算结果的最高位，若最高位为1则SF为1，否则为0，反映了有符号数运算结果的正负（0正1负） |
| OF（overflow flag） | 溢出标志 | 反映有符号数运算结果是否产生溢出，是置1，否置0 |
| PF（parity flag） | 奇偶标志 | 偶数置1奇数置0 |
| AF | 辅助进位标志 | - |

### 状态标志操作指令

| 指令 | 中文名 | 格式 | 解释 |
| --- | --- | --- | --- |
| CLC（clear carry flag） | 清进位标志指令 | CLC | 使进位标志CF为0 |
| STC(set carry flag) | 置进位标志指令 | STC | 使进位标志CF为1 |
| CMC（complement carry flag） | 进位标志取反指令 | CMC | 使进位标志CF取反 |
| LAHF（load status flags into AH register） | 获取状态标志操作指令 | LAHF | 把位于标志寄存器低端的5个状态标志位（p26图2.3）信息同时送到寄存器AH的对应位 |
| SAHF（store AH into Flags） | 设置状态标志操作指令 | SAHF | 对标志寄存器中的低8位产生影响，使得状态标志位SF、ZF、AF、PF和CF分别成为来自寄存器AH中对应位的值，但保留位（位1、位3、位5）不受影响 |

## 带进位加减指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| ADC（add with carry） | 带进位加法指令 | ADC DEST,SRC | DEST<=DEST SRC CF | 与add指令不同之处是要再加上进位标志cf的值 |
| SBB(substraction with borrow) | 带借位减法 | SBB DEST,SRC | DEST<=DEST-(SRC CF) | 与sub指令不同之处是要再减上借位标志cf的值 |

## 取有效地址指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| LEA（load effective address） | 取有效地址指令 | LEA REC,OPRD | 把操作数oprd的有效地址传送到操作数rec，源操作数oprd必须是一个存储器操作数，目的操作数rec必须是一个16位或32位的通用寄存器 | 与mov指令的区别：mov：移动地址中的值； lea：将地址进行移动 |

## 指令指针寄存器和简单控制转移指令

### 常用条件转移指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| CMP | 比较指令 | CMP DEST,SRC | 根据dest-src的差影响各状态标志寄存器 | 不把dest-src的结果送入dest |
| JMP | 无条件段内直接转移指令 | JMP LABEL | 使控制无条件地转移到标号为label的位置 | 无条件转移指令本身不影响标志 |

### 堆栈和堆栈操作

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| PUSH | 进栈指令 | PUSH SRC | 把源操作数src压入堆栈 | 源操作数src可以是32位通用寄存器、16位通用寄存器和段寄存器，也可以是双字存储单元或者字符存储单元，还可以是立即数 |
| POP | 出栈指令 | POP DEST | 从栈顶弹出一个双字或字数据到目的操作数 | 如果目的操作数是双字的，那么就从栈顶弹出一个双字数据，否则，从栈顶弹出一个字数据，出栈至少弹出一个字（16位） |
| PUSHA | 16位通用寄存器全进栈指令 | PUSHA | 将所有8个16位通用寄存器的内容压入堆栈 | 压入顺序是AX CX DX BX SP BP SI DI，然后对战指针寄存器SP的值减16，所以SP进栈的内容是PUSHA指令执行之前的值 |
| POPA | 16位通用寄存器全出栈指令 | POPA | 以PUSHA相反的顺序从堆栈中弹出内容，从而恢复PUSHA之前的寄存器状态 | SP的值不是由堆栈弹出的，而是通过增加16来恢复 |
| PUSHAD | 32位通用寄存器全进栈指令 | PUSHAD | 将所有8个32位通用寄存器的内容压入堆栈 | 压入顺序是EAX ECX EDX EBX ESP EBP ESI EDI，然后对战指针寄存器SP的值减32，所以SP进栈的内容是PUSHAD指令执行之前的值 |
| POPAD | 32位通用寄存器全出栈指令 | POPAD | 以PUSHAD相反的顺序从堆栈中弹出内容，从而恢复PUSHAD之前的寄存器状态 | ESP的值不是由堆栈弹出的，而是通过增加32来恢复 |

## 过程调用和返回指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| CALL | 过程调用指令 | CALL LABEL | 段内直接调用LABEL | 与jmp的区别在于call指令会在调用label之前保存返回地址（call 中return之后主程序还可以继续执行，jmp 当label执行完毕后不能返回主程序继续执行） |
| RET | 段内过程返回指令 | RET | 使子程序结束，继续执行主程序 |

## 算术逻辑运算指令

| 指令 | 中文名 |
| --- | --- |
| MUL | 无符号数乘法指令 |
| IMUL | 有符号数乘法指令 |
| IMUL DEST，SRC | 有符号数乘法指令 |
| IMUL DEST,SRC1,SRC2 | 有符号数乘法指令 |
| DIV | 无符号数除法指令 |
| IDIV OPRD | 有符号数除法指令 |

## 符号拓展指令

| 指令 | 中文名 | 格式 | 解释 |
| --- | --- | --- | --- |
| CBW | 字节转化为字指令 | CBW | 把寄存器AL中的值符号拓展到寄存器AH |
| CWD | 字转化为双字指令 | CWD | 把寄存器AX中的值符号拓展到寄存器DX |
| CDQ | 双字转化为四字指令 | CDQ | 把寄存器EAX中的值符号拓展到EDX |
| CWDE | 字转化为双字指令 | CWDE | 把AX中的值符号拓展到EAX的高16位 |

## 拓展传送指令
| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| MOVSX | 符号拓展传送指令 | MOVSX DEST,SRC | 把源操作数SRC符号拓展后送至目的操作数DEST | src可以是通用寄存器或者存储单元，但是dest只能是通用寄存器（零拓展传送指令不会改变源操作数，也不影响标志寄存器的状态） |
| MOVZX | - | MOVZX DEST,SRC | 把源操作数SRC零拓展后送至目的操作数DEST | 零拓展传送指令不会改变源操作数，也不影响标志寄存器的状态 |

## 逻辑运算指令
| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| NOT | 否运算指令 | NOT OPRD | 把操作数OPRD按位取反，然后送回OPRD |
| AND | 与运算指令 | AND DEST，SRC | 把两个操作数进行与运算之后结果送回DEST | 同1得1，否则得0 |
| OR | 或运算指令 | OR DEST，SRC | 把两个操作数进行或运算之后结果送回DEST | 同0得0，否则得1 |
| XOR | 异或运算 | XOR DEST，SRC | 把两个操作数进行异或运算之后结果送回DEST | 相同得0不同得1 |
| TEST | 测试指令 | TEST DEST，SRC | 与AND指令类似，将各位相与，但是结果不送回DEST，仅影响状态位标志，指令执行后，ZF、PF、SF反映运算结果，CF和OF被清零 | 通常用于检测某些位是否为1，但又不希望改变操作数的值 |

## 移位指令

### 一般移位指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| SAL | 算术左移 | SAL OPRD，count | 把操作数oprd左移count位，右边补0 | 与shl指令一样。通过截取count的低5位，实际的移位数被限于0到31之间。 |
| SHL | 逻辑左移 | SHL OPRD，count | 把操作数oprd左移count位，右边补0 | 与sal指令一样。通过截取count的低5位，实际的移位数被限于0到31之间。 |
| SAR | 算术右移 | SAR OPRD，count | 把操作数oprd右移count位，同时每右移一位，左边补符号位，移出的最低位进入标志位CF | 通过截取count的低5位，实际的移位数被限于0到31之间。 |
| SHR | 逻辑右移 | SHR OPRD，count | 把操作数oprd右移count位，左边补0，移出的最低位进入标志位CF | 通过截取count的低5位，实际的移位数被限于0到31之间。 |

### 循环移位指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| ROL | 左循环移位指令 | ROL OPRD,count |  | 通过截取count的低5位，实际的移位数被限于0到31之间。 |
| ROR | 右循环移位指令 | ROR OPRD,count |  | 通过截取count的低5位，实际的移位数被限于0到31之间。 |
| RCL | 带进位左循环移位 | RCL OPRD,count | 相当于CF在最高位参与循环移位 | 大循环左移。通过截取count的低5位，实际的移位数被限于0到31之间。 |
| RCR | 带进位右循环移位 | RCR OPRD,count | 相当于CF在最高位参与循环移位 | 大循环右移。通过截取count的低5位，实际的移位数被限于0到31之间。 |

## 循环指令

| 指令 | 中文名 | 格式 | 解释 | 备注 |
| --- | --- | --- | --- | --- |
| LOOP | 计数循环指令 | LOOP LABEL | 使ECX的值减1，当ECX的值不为0的时候跳转至LABEL，否则执行LOOP之后的语句 |
| LOOPE | 等于循环指令 | LOOPE LABEL | 使ECX的值减1，如果结果不等于0并且零标志ZF等于1（表示相等），那么就转移到LABEL，否则执行LOOPE之后的语句 |
| LOOPZ | 零循环指令 | LOOPZ LABEL | 使ECX的值减1，如果结果不等于0并且零标志ZF等于1（表示相等），那么就转移到LABEL，否则执行LOOPZ之后的语句 |
| LOOPNE | 不等于循环指令 | LOOPE LABEL | 使ECX的值减1，如果结果不等于0并且零标志ZF等于0（表示不相等），那么就转移到LABEL，否则执行LOOPNE之后的语句 |
| LOOPNZ | 非零循环指令 | LOOPNZ LABEL | 使ECX的值减1，如果结果不等于0并且零标志ZF等于0（表示不相等），那么9就转移到LABEL，否则执行LOOPNZ之后的语句 |
| JECXZ | 计数转移指令 | JECXZ LABEL | 当寄存器ECX的值为0时转移到LABEL，否则顺序执行 | 通常在循环开始之前使用该指令，所以循环次数为0时，就可以跳过循环体 |

