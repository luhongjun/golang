# Wire 依赖项注入编译组件

Wire 是一个轻巧的 Golang 依赖注入工具。它由 Go Cloud 团队开发，通过自动生成代码的方式在编译期完成依赖注入。

依赖注入是保持软件 “低耦合、易维护” 的重要设计准则之一。

此准则被广泛应用在各种开发平台之中，有很多与之相关的优秀工具。

其中最著名的当属 Spring，Spring IOC 作为框架的核心功能对 Spring 的发展到今天统治地位起了决定性作用。

事实上， 软件开发 S.O.L.I.D 原则 中的“D”， 就专门指代这个话题。

**推荐阅读**
- [官方类库 - google/wire](https://github.com/google/wire)
- [Go：一文读懂 Wire](https://studygolang.com/articles/27163?fr=sidebar)
- [Golang依赖注入框架wire全攻略](https://studygolang.com/articles/22266?fr=sidebar)

作为一个代码生成工具， Wire 可以生成 Go 源码并在编译期完成依赖注入。 
它不需要反射机制或 Service Locators 。 后面会看到， Wire 生成的代码与手写无异。 这种方式带来一系列好处：

- 方便 debug，若有依赖缺失编译时会报错
- 因为不需要 Service Locators， 所以对命名没有特殊要求
- 避免依赖膨胀。 生成的代码只包含被依赖的代码，而运行时依赖注入则无法作到这一点
- 依赖关系静态存于源码之中， 便于工具分析与可视化

## 安装

直接运行以下命令，并被安装到 $GOPATH/bin，并确保 $GOPATH/bin 在 $PATH 中，则可以被任何目录调用。
```shell script
go get github.com/google/wire/cmd/wire
```

## 核心概念

Wire的核心概念有两个：Provider 和 Injector

### Provider

生成组件的普通方法。这些方法接收所需依赖作为参数，创建组件并将其返回。

组件可以是对象或函数。而事实上它可以是任何类型，但单一类型在整个依赖图中只能有单一 provider。

因此返回 int 类型的 provider 不是个好主意。 

对于这种情况， 可以通过定义类型别名来解决。例如先定义type Category int ，然后让 provider 返回 Category 类型。

```gotemplate
// 以下能看得出来依赖关系是：NewUserLoadFunc -> NewDb -> DefaultConnectionOpt
func DefaultConnectionOpt() *ConnectionOpt {
    // NewDb provide an Db object
}
func NewDb(opt *ConnectionOpt) (*Db, error) {
    // NewUserLoadFunc provide a function which can load user
}
func NewUserLoadFunc(db *Db) (func(int) *User, error) {
    //
}

// 实践中， 一组业务相关的 provider 时常被放在一起组织成 ProviderSet，以方便维护与切换。
var DbSet = wire.NewSet(DefaultConnectionOpt, NewDb)
```

### Injector

由wire自动生成的函数。函数内部会按根据依赖顺序调用相关 providers。

为了生成此函数，我们在 wire.go (文件名非强制，但一般约定如此)文件中定义 injector 函数签名。 然后在函数体中调用 wire.Build ，并以所需 provider 作为参数（无须考虑顺序）。

由于wire.go中的函数并没有真正返回值，为避免编译器报错，简单地用panic函数包装起来即可。不用担心执行时报错， 因为它不会实际运行，只是用来生成真正的代码的依据。

一个简单的 wire.go 示例：
```gotemplate
// +build wireinject //这个 build tag 确保在常规编译时忽略 wire.go 文件（因为常规编译时不会指定 wireinject 标签）

package main

import "github.com/google/wire"

func UserLoader()(func(int)*User, error){
   panic(wire.Build(NewUserLoadFunc, DbSet))
}

var DbSet = wire.NewSet(DefaultConnectionOpt, NewDb)
```


## 基本用法

有了这些代码以后，运行`wire 命令`将生成 wire_gen.go 文件，其中保存了 injector 函数的真正实现。 

wire.go 中若有非 injector 的代码将被原样复制到 wire_gen.go 中（虽然技术上允许，但不推荐这样作）。 

生成代码如下：
```gotemplate
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
   "github.com/google/wire"
)

// Injectors from wire.go:

func UserLoader() (func(int) *User, error) {
   connectionOpt := DefaultConnectionOpt()
   db, err := NewDb(connectionOpt)
   if err != nil {
      return nil, err
   }
   v, err := NewUserLoadFunc(db)
   if err != nil {
      return nil, err
   }
   return v, nil
}

// wire.go:

var DbSet = wire.NewSet(DefaultConnectionOpt, NewDb)
```

## 高级用法

| 方法 | 返回值 |
| --- | --- |
| wire.Bind | Binding |
| wire.Build | string |
| wire.Struct | StructProvider |
| wire.FieldsOf | StructFields |
| wire.Value |  ProvidedValue |
| wire.InterfaceValue | ProvidedValue |

### 接口注入

有时候需要自动注入一个接口， 这时有两个选择：

1. 较直接的作法是在 provider 中生成具体类， 然后返回接口类型。 但这不符合Golang 代码规范。一般不采用
2. 让 provider 返回具体类，但在 injector 声明环节作文章，将类绑定成接口，例如：
```gotemplate
// FooInf, an interface
// FooClass, an class which implements FooInf
// fooClassProvider, a provider function that provider *FooClass
var set = wire.NewSet(
    fooClassProvider,
    wire.Bind(new(FooInf), new(*FooClass)) // bind class to interface
)
```

### 属性自动注入
有时我们不需什么特定的初始化工作， 只是简单地创建一个对象实例， 为其指定属性赋值，然后返回。当属性多的时候，这种工作会很无聊。
```gotemplate
// In provider.go
type App struct {
    Foo *Foo
    Bar *Bar
}

func DefaultApp(foo *Foo, bar *Bar)*App{
    return &App{Foo: foo, Bar: bar}
}

// In wire.go
wire.Build(provideFoo, provideBar, DefaultApp)

// 指定属性名来注入特定属性
wire.Build(provideFoo, provideBar, wire.Struct(new(App),"Foo","Bar")

// 如果要注入全部属性，则有更简化的写法：
wire.Build(provideFoo, provideBar, wire.Struct(new(App), "*")
```

如果 struct 中有个别属性不想被注入，那么可以修改 struct 定义：
```gotemplate
type App struct {
    Foo *Foo
    Bar *Bar
    NoInject int `wire:"-"`
}
```

### 值绑定(wire.Value 与 wire.InterfaceValue)
虽不常见，但有时需要为基本类型的属性绑定具体值， 这时可以使用 wire.Value :
```gotemplate
// In provider.go
type Foo struct {
    X int
}

// In wire.go
wire.Build(wire.Value(Foo{X: 42}))

// 为接口类型绑定具体值，可以使用 wire.InterfaceValue：
wire.Build(wire.InterfaceValue(new(io.Reader), os.Stdin))
```

### 把对象属性用作Provider
有时我们只是需要用某个对象的属性作为 Provider，例如：
```gotemplate
// provider
func provideBar(foo Foo) *Bar {
    return foo.Bar
}
// injector
wire.Build(provideFoo, provideBar)

// 可以用 wire.FieldsOf 加以简化，省掉啰嗦的 provider:
wire.Build(provideFoo, wire.FieldsOf(new(Foo), "Bar"))
```

### 清理函数
前面提到若 provider 和 injector 函数有返回错误， 那么 wire 会自动处理。除此以外，wire 还有另一项自动处理能力： 清理函数。

所谓清理函数是指型如 func() 的闭包， 它随 provider 生成的组件一起返回， 确保组件所需资源可以得到清理。

清理函数典型的应用场景是文件资源和网络连接资源，例如：
```gotemplate
type App struct {
   File *os.File
   Conn net.Conn
}

func provideFile() (*os.File, func(), error) {
   f, err := os.Open("foo.txt")
   if err != nil {
      return nil, nil, err
   }
   cleanup := func() {
      if err := f.Close(); err != nil {
         log.Println(err)
      }
   }
   return f, cleanup, nil
}

func provideNetConn() (net.Conn, func(), error) {
   conn, err := net.Dial("tcp", "foo.com:80")
   if err != nil {
      return nil, nil, err
   }
   cleanup := func() {
      if err := conn.Close(); err != nil {
         log.Println(err)
      }
   }
   return conn, cleanup, nil
}
```

上述代码定义了两个 provider 分别提供了文件资源和网络连接资源，依赖关系如下：

wire.go 文件如下：
```gotemplate
// +build wireinject

package main

import "github.com/google/wire"

func NewApp() (*App, func(), error) {
   panic(wire.Build(
      provideFile,
      provideNetConn,
      wire.Struct(new(App), "*"),
   ))
}
```

注意由于 provider 返回了清理函数， 因此 injector 函数签名也必须返回，否则将会报错

wire_gen.go 文件如下：
```gotemplate
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

// Injectors from wire.go:

func NewApp() (*App, func(), error) {
   file, cleanup, err := provideFile()
   if err != nil {
      return nil, nil, err
   }
   conn, cleanup2, err := provideNetConn()
   if err != nil {
      cleanup()
      return nil, nil, err
   }
   app := &App{
      File: file,
      Conn: conn,
   }
   return app, func() {
      cleanup2()
      cleanup()
   }, nil
}
```

生成代码中有两点值得注意：
- 当 provideNetConn 出错时会调用 cleanup() ， 这确保了即使后续处理出错也不会影响前面已分配资源的清理。
- 最后返回的闭包自动组合了 cleanup2() 和 cleanup() 。 意味着无论分配了多少资源， 只要调用过程不出错，他们的清理工作就会被集中到统一的清理函数中。 最终的清理工作由 injector 的调用者负责