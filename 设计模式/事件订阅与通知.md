# 事件订阅与通知

- 实现方式：通过列表的方式
```go
// Package main serves as an example application that makes use of the observer pattern.
// Playground: https://play.golang.org/p/cr8jEmDmw0
package main

import (
	"fmt"
	"time"
)

type (
	// Event 定义事件
	// Event defines an indication of a point-in-time occurrence.
	Event struct {
		// Data in this case is a simple int, but the actual
		// implementation would depend on the application.
		Data int64
	}

	// Observer 定义观察者
	// Observer defines a standard interface for instances that wish to list for
	// the occurrence of a specific event.
	Observer interface {
		// OnNotify allows an event to be "published" to interface implementations.
		// In the "real world", error handling would likely be implemented.
		OnNotify(Event)
	}
)

//// 事件观察者
type eventObserver struct {
	id int
}

func (o *eventObserver) OnNotify(e Event) {
	fmt.Printf("*** Observer %d received: %d\n", o.id, e.Data)
}

//// 事件与观察者调度器
type eventNotifier struct {
	// Using a map with an empty struct allows us to keep the observers
	// unique while still keeping memory usage relatively low.
	observers map[Observer]struct{}
}

func (o *eventNotifier) Register(l Observer) {
	o.observers[l] = struct{}{}
}

func (p *eventNotifier) Notify(e Event) {
	for o := range p.observers {
		o.OnNotify(e)
	}
}

func main() {
	// Initialize a new Notifier.
	n := eventNotifier{
		observers: map[Observer]struct{}{},
	}

	// Register a couple of observers.
	n.Register(&eventObserver{id: 1})
	n.Register(&eventObserver{id: 2})

	// A simple loop publishing the current Unix timestamp to observers.
	// @see https://studygolang.com/articles/18404?fr=sidebar  关于 time 包的 Timer 定时器
	stop := time.NewTimer(10 * time.Second).C
	tick := time.NewTicker(time.Second).C
	for {
		select {
		case <-stop: //	10秒后自动结束
			return
		case t := <-tick: // 每1秒进行一次通知
			n.Notify(Event{Data: t.UnixNano()})
		}
	}
}
```

- 方式二：通过通道的方式
```go
package main

// 发布-订阅是一种消息传递模式，用于在不同组件之间传递消息，而这些组件不知道彼此的身份

import (
	"fmt"
	"testing"
	"time"
)

// 定义消息体
type Message struct {
	title	string
	content	string
}

type Receiver 	chan<- Message
type Sender		<-chan Message

// 定义订阅
type Subscription struct {
	receiver	Receiver
	messageBox	Sender
}

// 定义主题
type Topic struct {
	theme			string
	Receivers		[]*Receiver
	Subscribers    	[]User
	MessageHistory 	[]Message
}

// 注册用户（订阅主题）
func (topic *Topic) Subscribe(user User) Subscription {
	// 将用户添加至订阅名单中
	topic.Subscribers = append(topic.Subscribers, user)

	// 为当前订阅的用户创建 Message 通知的通道
	userPipeline := make(chan Message, 100)
	var receiver Receiver = userPipeline
	var messageBox Sender = userPipeline

	// 添加接收列表
	topic.Receivers = append(topic.Receivers, &receiver)

	// Create a subscription
	return Subscription{
		receiver:   receiver,
		messageBox: messageBox,
	}
}

func (topic *Topic) Publish(msg Message) {
	// 记录发布的消息
	topic.MessageHistory = append(topic.MessageHistory, msg)

	// 向全体订阅者发送消息
	for _, receiver := range topic.Receivers {
		go func(receiver *Receiver) {
			*receiver <- msg
		}(receiver)
	}
}

// 定义用户 User
type User struct {
	id		uint64
	name 	string
}

// 监听等待订阅消息
func (user *User) waitMessage(s Subscription)  {
	for  {
		msg := <- s.messageBox
		fmt.Println("通知用户：" + user.name + ";" + "信息：" + msg.content)
	}
}

func main()  {
	// 实例化主题
	topic := Topic{
		theme:          "财经类消息",
		Subscribers:    nil,
		MessageHistory: nil,
	}

	// 实例化用户
	userA := User{
		id:   100,
		name: "Lu",
	}

	userB := User{
		id:   101,
		name: "Hong",
	}

	// 用户订阅
	subscriptionA := topic.Subscribe(userA)
	subscriptionB := topic.Subscribe(userB)
	// 发布消息
	topic.Publish(Message{
		title:   "今日股市情况",
		content: "上涨0.43%",
	})

	go userA.waitMessage(subscriptionA)
	go userB.waitMessage(subscriptionB)

	time.Sleep(time.Second * time.Duration(300))
}
```