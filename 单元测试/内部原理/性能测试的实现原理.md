# 性能测试的实现原理

testing.B 的数据结构如下：

```go
package testing

type B struct {
	common                  // 与testing.T共享的testing.common，负责记录日志、状态等
	importPath       string // import path of the package containing the benchmark
	context          *benchContext
	N                int           // 每个测试中用户代码执行次数
	previousN        int           // number of iterations in the previous run
	previousDuration time.Duration // total duration of the previous run
	benchFunc        func(b *B)    // 性能测试函数
	benchTime        time.Duration // 性能测试函数最少执行的时间，默认为1s，可以通过参数'-benchtime 10s'指定
	bytes            int64         // 每次迭代处理的字节数
	missingBytes     bool          // one of the subbenchmarks does not have bytes set.
	timerOn          bool          // 是否已开始计时
	showAllocResult  bool
	result           BenchmarkResult // 测试结果
	parallelism      int             // RunParallel creates parallelism*GOMAXPROCS goroutines
	// The initial states of memStats.Mallocs and memStats.TotalAlloc.
	startAllocs uint64 // 计时开始时堆中分配的对象总数
	startBytes  uint64 // 计时开始时时堆中分配的字节总数
	// The net total of this test after being run.
	netAllocs uint64 // 计时结束时，堆中增加的对象总数
	netBytes  uint64 // 计时结束时，堆中增加的字节总数
}

// StartTimer 启动计时并初始化内存相关计数，测试执行时会自动调用，一般不需要用户启动
func (b *B) StartTimer() {
	if !b.timerOn {
		runtime.ReadMemStats(&memStats)    // 读取当前堆内存分配信息
		b.startAllocs = memStats.Mallocs   // 记录当前堆内存分配的对象数
		b.startBytes = memStats.TotalAlloc // 记录当前堆内存分配的字节数
		b.start = time.Now()               // 记录测试启动时间
		b.timerOn = true                   // 标记计时标志
	}
}

// StopTimer 负责停止计时，并累加相应的统计值
// 需要注意的是，StopTimer()并不一定是测试结束，一个测试中有可能有多个统计阶段，所以其统计值是累加的
func (b *B) StopTimer() {
	if b.timerOn {
		b.duration += time.Since(b.start)                // 累加测试耗时
		runtime.ReadMemStats(&memStats)                  // 读取当前堆内存分配信息
		b.netAllocs += memStats.Mallocs - b.startAllocs  // 累加堆内存分配的对象数
		b.netBytes += memStats.TotalAlloc - b.startBytes // 累加堆内存分配的字节数
		b.timerOn = false                                // 标记计时标志
	}
}

// ResetTimer 重置计时器，相应的也会把其他统计值也重置
func (b *B) ResetTimer() {
	if b.timerOn {
		runtime.ReadMemStats(&memStats)    // 读取当前堆内存分配信息
		b.startAllocs = memStats.Mallocs   // 记录当前堆内存分配的对象数
		b.startBytes = memStats.TotalAlloc // 记录当前堆内存分配的字节数
		b.start = time.Now()               // 记录测试启动时间
	}
	b.duration = 0  // 清空耗时
	b.netAllocs = 0 // 清空内存分配对象数
	b.netBytes = 0  // 清空内存分配字节数
}

// SetBytes records the number of bytes processed in a single operation.
// If this is called, the benchmark will report ns/op and MB/s.
// 用来设置单次迭代处理的字节数，一旦设置了这个字节数，那么输出报告中将会呈现“xxx MB/s”的信息，用来表示待测函数处理字节的性能。待测函数每次处理多少字节数只有用户清楚，所以需要用户设置。
//举个例子，待测函数每次执行处理1M数据，如果我们想看待测函数处理数据的性能，那么我们在测试中设置SetByte(1024 *1024)，假如待测函数需要执行1s的话，那么结果中将会出现 “1 MB/s”（约等于）的信息
func (b *B) SetBytes(n int64) {
	b.bytes = n
}
```

## B.N是如何调整的？

B.launch()方法里最终决定B.N的值。我们看下伪代码：
```gotemplate
func (b *B) launch() { // 此方法自动测算执行次数，但调用前必须调用run1以便自动计算次数
    d := b.benchTime
    for n := 1; !b.failed && b.duration < d && n < 1e9; { // 最少执行b.benchTime（默认为1s）时间，最多执行1e9次
        last := n
        n = int(d.Nanoseconds()) // 预测接下来要执行多少次，b.benchTime/每个操作耗时
        if nsop := b.nsPerOp(); nsop != 0 {
            n /= int(nsop)
        }
        n = max(min(n+n/5, 100*last), last+1) // 避免增长较快，先增长20%，至少增长1次
        n = roundUp(n) // 下次迭代次数向上取整到10的指数，方便阅读
        b.runN(n)
    }
}
```

不考虑程序出错，而且用户没有主动停止测试的场景下，每个性能测试至少要执行b.benchTime长的秒数，默认为1s。先执行一遍的意义在于看用户代码执行一次要花费多长时间，如果时间较短，那么b.N值要足够大才可以测得更精确，如果时间较长，b.N值相应的会减少，否则会影响测试效率。

最终的b.N会被定格在某个10的指数级，是为了方便阅读测试报告。

## 内存是如何统计的？

我们知道在测试开始时，会把当前内存值记入到b.startAllocs和b.startBytes中，测试结束时，会用最终内存值与开始时的内存值相减，得到净增加的内存值，并记入到b.netAllocs和b.netBytes中。

每个测试结束，会把结果保存到BenchmarkResult对象里，该对象里保存了输出报告所必需的统计信息：
```gotemplate
type BenchmarkResult struct {
    N         int           // 用户代码执行的次数
    T         time.Duration // 测试耗时
    Bytes     int64         // 用户代码每次处理的字节数，SetBytes()设置的值
    MemAllocs uint64        // 内存对象净增加值
    MemBytes  uint64        // 内存字节净增加值
}
```

其中MemAllocs和MemBytes分别对应b.netAllocs和b.netBytes。

那么最终统计时只需要把净增加值除以b.N即可得到每次新增多少内存了。

每个操作内存对象新增值：
```gotemplate
func (r BenchmarkResult) AllocsPerOp() int64 {
    return int64(r.MemAllocs) / int64(r.N)
}
```

每个操作内存字节数新增值：
```gotemplate
func (r BenchmarkResult) AllocedBytesPerOp() int64 {
    if r.N <= 0 {
        return 0
    }
    return int64(r.MemBytes) / int64(r.N)
}
```