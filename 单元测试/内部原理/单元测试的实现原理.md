# 单元测试的实现原理

testing.T 的数据结构如下：

```go
package testing

type T struct {
	common                  //即 testing.Common
	isParallel bool         // 示当前测试是否需要并发，如果测试中执行了t.Parallel()，则此值为true
	context    *testContext // 控制测试的并发调度
}

type testContext struct {
	match *matcher // 匹配器，用于管理测试名称匹配、过滤等

	mu sync.Mutex // 互斥锁，用于控制testContext成员的互斥访问

	// 用于通知测试可以并发执行的控制管道，测试并发达到最大限制时，需要阻塞等待该管道的通知事件
	startParallel chan bool

	// 当前并发执行的测试个数
	running int

	// 等待并发执行的测试个数，所有等待执行的测试都阻塞在startParallel管道处
	numWaiting int

	// 最大并发数，默认为系统CPU数，可以通过参数-parallel n指定
	maxParallel int
}

// 等待并发执行
//如果一个测试使用t.Parallel()启动并发，这个测试并不是立即被并发执行，需要检查当前并发执行的测试数量是否达到最大值，这个检查工作统一放在testContext.waitParallel()实现的
func (c *testContext) waitParallel() {
	c.mu.Lock()
	if c.running < c.maxParallel { // 如果当前运行的测试数未达到最大值，直接返回
		c.running++
		c.mu.Unlock()
		return
	}
	c.numWaiting++ // 如果当前运行的测试数已达最大值，需要阻塞等待
	c.mu.Unlock()
	<-c.startParallel
}

// 并发测试结束
//当并发测试结束后，会通过release()方法释放一个信号，用于启动其他等待并发测试的函数
func (c *testContext) release() {
	c.mu.Lock()
	if c.numWaiting == 0 { // 如果没有函数在等待，直接返回
		c.running--
		c.mu.Unlock()
		return
	}
	c.numWaiting-- // 如果有函数在等待，释放一个信号
	c.mu.Unlock()
	c.startParallel <- true // Pick a waiting test to be run.
}

// 测试执行
// tRunner传一个经调度者设置过的testing.T参数和一个测试函数，执行时记录开始时间，然后将testing.T参数传入测试函数并同步等待其结束。
//tRunner在defer语句中记录测试执行耗时，并上报日志，最后发送结束信号
func tRunner(t *T, fn func(t *T)) {
	defer func() {
		t.duration += time.Since(t.start)
		signal := true

		t.report() // 测试执行结束后向父测试报告日志

		t.done = true
		t.signal <- signal // 向调度者发送结束信号
	}()

	t.start = time.Now()
	fn(t)

	t.finished = true
}

// Run 启动子测试
//启动一个子测试，这个子测试可以是用户的测试函数中主动调用Run()方法启动的，如果用户没有主动调用Run()方法，那么用户的测试函数也是被调度程序以Run()方法启动的。可以说，所有的测试都是Run()方法启动的
func (t *T) Run(name string, f func(t *T)) bool {
	t = &T{ // 创建一个新的testing.T用于执行子测试
		common: common{
			barrier: make(chan bool),
			signal:  make(chan bool),
			name:    testName,
			parent:  &t.common,
			level:   t.level + 1, // 子测试层次+1
			chatty:  t.chatty,
		},
		context: t.context, // 子测试的context与父测试相同
	}
	go tRunner(t, f) // 启动协程执行子测试
	if !<-t.signal { // 阻塞等待子测试结束信号，子测试要么执行结束，要么以Parallel()执行。如果信号为'false'，说明出现异常退出
		runtime.Goexit()
	}
	return !t.failed // 返回子测试的执行结果
}

// Parallel 将当前测试加入到并发队列中
func (t *T) Parallel() {
	t.isParallel = true

	t.duration += time.Since(t.start) // 启动并发测试有可能要等待，等待期间耗时需要剔除，此处相当于先记录当前耗时，并发执行开始后再累加

	t.parent.sub = append(t.parent.sub, t) // 将当前测试加入到父测试的列表中，由父测试调度

	t.signal <- true         // Release calling test. 当前测试即将进入并发模式，标记测试结束，以便父测试不必等待并退出Run()
	<-t.parent.barrier       // Wait for the parent test to complete.  等待父测试发送子测试启动信号
	t.context.waitParallel() // 阻塞等待并发调度

	t.start = time.Now() // 开始并发执行，重新标记启动时间，这是第二段耗时
}
```