# 定时器 

定时器是进程规划自己在未来某一时刻接获通知的一种机制。有两种定时：
- Timer：到达指定时间触发且只触发一次
- Ticker：间隔特定时间触发

## Timer

Timer 类型代表单次时间事件。当 Timer 到期时，当时的时间会被发送给 C (channel)，除非 Timer 是被 AfterFunc 函数创建的

### 内部实现源码分析

Timer类型定义如下：
```gotemplate
type Timer struct {
    C <-chan Time     // The channel on which the time is delivered.
    r runtimeTimer
}

// 定义在 sleep.go 文件中，必须和 runtime 包中 time.go 文件中的 timer 必须保持一致：
type runtimeTimer struct {
    pp       uintptr
    when     int64
    period   int64
    f        func(interface{}, uintptr) // NOTE: must not be closure
    arg      interface{}
    seq      uintptr
    nextwhen int64
    status   uint32
}
```

当我们创建了一个Timer定时器`time.NewTimer(time.Hour)`后，会发生什么？
```gotemplate
// NewTimer creates a new Timer that will send
// the current time on its channel after at least duration d.
func NewTimer(d Duration) *Timer {
    c := make(chan Time, 1)
    t := &Timer{
        C: c,
        r: runtimeTimer{
            when: when(d),
            f:    sendTime,
            arg:  c,
        },
    }
    startTimer(&t.r)
    return t
}
```

**解析说明：**

- 在`when`表示的时间到时，会往`Timer.C`中发送当前时间。`when`表示的时间是纳秒时间，正常通过`runtimeNano() + int64(d)`赋值：
    - 调用系统调用`clock_gettime`获取时钟值（这是 POSIX 时钟）。其中`clockid_t`时钟类型是`CLOCK_MONOTONIC`，也就是不可设定的恒定态时钟。具体的是什么时间，SUSv3 规定始于未予规范的过去某一点，Linux 上，始于系统启动。
    - 如果`clock_gettime`不存在，则使用精度差些的系统调用`gettimeofday`。
    
- `f`参数的值是 sendTime，定时器时间到时，会调用`f`，并将`arg`和`seq`传给`f`。

- 定时器的具体实现逻辑，都在 runtime 中的 time.go 中，它的实现，没有采用经典 Unix 间隔定时器`setitimer`系统调用，也没有采用POSIX间隔式定时器（相关系统调用：`timer_create`、`timer_settime`和`timer_delete`），而是通过四叉树堆 (heep) 实现的（`runtimeTimer`结构中的`i`字段，表示在堆中的索引）。通过构建一个最小堆，保证最快拿到到期了的定时器执行。定时器的执行，在专门的 goroutine 中进行的：`go timerproc()`。有兴趣的话可以阅读 runtime/time.go 的源码。

### Timer 相关函数或方法的使用

- time.After
- time.AfterFunc
- timer.Stop 
  
如果定时器还未触发，Stop 会将其移除，并返回 true；否则返回 false；后续再对该 Timer 调用 Stop，直接返回 false

- timer.Reset

先调用`stopTimer`再调用`startTimer`，类似于废弃之前的定时器，重新启动一个定时器

```gotemplate
// After waits for the duration to elapse and then sends the current time
// on the returned channel.
// It is equivalent to NewTimer(d).C.
// The underlying Timer is not recovered by the garbage collector
// until the timer fires. If efficiency is a concern, use NewTimer
// instead and call Timer.Stop if the timer is no longer needed.
func After(d Duration) <-chan Time {
	return NewTimer(d).C
}

// AfterFunc waits for the duration to elapse and then calls f
// in its own goroutine. It returns a Timer that can
// be used to cancel the call using its Stop method.
func AfterFunc(d Duration, f func()) *Timer {
    t := &Timer{
    r: runtimeTimer{
    when: when(d),
    f:    goFunc,
    arg:  f,
    },
    }
    startTimer(&t.r)
    return t
}

// For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer
// has already expired and the function f has been started in its own goroutine;
// Stop does not wait for f to complete before returning.
// If the caller needs to know whether f is completed, it must coordinate
// with f explicitly.
func (t *Timer) Stop() bool {
    if t.r.f == nil {
    panic("time: Stop called on uninitialized Timer")
    }
    return stopTimer(&t.r)
}

// Note that it is not possible to use Reset's return value correctly, as there
// is a race condition between draining the channel and the new timer expiring.
// Reset should always be invoked on stopped or expired channels, as described above.
// The return value exists to preserve compatibility with existing programs.
func (t *Timer) Reset(d Duration) bool {
    if t.r.f == nil {
    panic("time: Reset called on uninitialized Timer")
    }
    w := when(d)
    return resetTimer(&t.r, w)
}
```

## 定时器的实际应用

略...